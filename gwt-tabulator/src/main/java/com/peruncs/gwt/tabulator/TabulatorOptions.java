package com.peruncs.gwt.tabulator;

import com.peruncs.gwt.utils.Callback1;
import com.peruncs.gwt.utils.Callback2;
import com.peruncs.gwt.utils.CallbackRet1;
import com.peruncs.gwt.utils.CallbackRet3;
import elemental2.core.JsMap;
import elemental2.core.JsObject;
import elemental2.dom.Event;
import elemental2.dom.Node;
import jsinterop.annotations.JsType;
import jsinterop.base.Any;
import jsinterop.base.JsPropertyMap;


/**
 * Tabulator options.
 */
@JsType
public class TabulatorOptions {

    /**
     * See Table Layout documentation. Possible values:
     * "fitData"
     * "fitDataFill"
     * "fitColumns"
     */
    public String layout;
    /**
     * By default it is possible to manually resize columns by dragging the borders of the column in both the column headers and the cells of the column.
     * If you want to alter this behaviour you can use the resizableColumns to choose where the resize handles are available. It supports four possible options:
     * <p>
     * true - enable column resizing from both cells and headers
     * "header" - enable column resizing from headers only
     * "cell" - enable column resizing from cells only
     * false - disable column resizing
     */
    public StringOrBoolean resizableColumns;
    /**
     * Minimum column width in px
     */
    public int columnMinWidth = 40;

    /**
     * If you set the autoColumns option to true, every time data is loaded into the table through the data option or through the setData function, Tabulator will examine the first row of the data and build columns to match that data.
     */
    public boolean autoColumns;

    public CallbackRet1<String, ColumnTitleValue[]> responsiveLayoutCollapseFormatter;

    public boolean responsiveLayoutCollapseUseFormatters;

    public boolean responsiveLayoutCollapseStartOpen;

    public String formatter;

    boolean autoResize;

    boolean resizableRows;
    public boolean virtualDom = true;

    public boolean resizable;
    public Integer virtualDomBuffer;

    /**
     * You can use the placeholder option to display a message to your users when the table has no data set. The function can either take a string to display or, the HTML or DOM Node to display in the empty table
     */
    public StringOrNode placeholder;

    /**
     * The footer element that the tables uses for holding pagination elements etc, is automatically generated by Tabulator.
     * If you want to use your own element for any reason, for example you want to add additional elements to the footer, you can use the footerElement option to pass either a CSS selector, a DOM node, or the HTML for the contents of footer element into the table.
     */
    public StringOrNode footerElement;

    //Virtual DOM
    public StringOrInteger height;
    /**
     * Enable header tooltips
     */
    public HeaderTooltipUnion tooltipsHeader;
    /**
     * "remote" - enable remote pagination.
     * "local"  - enable local pagination.
     */
    public String pagination;


    public ColumnOptions[] columns;

    public boolean sortOrderReverse;

    /**
     * By default you can sort by multiple columns at the same time by holding the ctrl or shift key when you click on the column headers.
     * if you wish to disable this behaviour, so only once column can be sorted at a time, you can set the columnHeaderSortMulti option to false
     */
    public boolean columnHeaderSortMulti;

    /**
     * When the table is first created it can be defined with an initial set of sorters. These can be set using the initialSort option. This will take the same sorter array as the setSort function.
     */
    public SortOrder[] initialSort;

    /**
     * Send sort data to the server instead of processing locally.
     */
    public boolean ajaxSorting;

    /**
     * The dataSorting callback is triggered whenever a sort event occurs, before sorting happens.
     */
    public Callback1<Sorter[]> dataSorting;


    /**
     * The dataSorted callback is triggered after the table dataset is sorted.
     */
    public Callback2<Sorter[], RowComponent[]> dataSorted;


    /**
     * Tabulator also allows you to define a row level formatter using the rowFormatter option. this lets you alter each row of the table based on the data it contains.
     * The function accepts one argument, the RowComponent for the row being formatted.
     * The example below changes the background colour of a row to blue if the col value for that row is "blue".
     */

    public Callback1<RowComponent> rowFormatter;


    public TooltipUnion tooltips;

    /**
     * By default Tabulator regenerates tooltips whenever data in a cell changes, however if you use a tooltip generation function that is dependant on values outside the cell this may mean the tooltip does not update as expected.
     * To get round this, you can use the tooltipGenerationMode parameter to make tooltips regenerate whenever the users mouse enters the cell. The parameter can have one of two values
     * load - Generate tooltip when value is loaded into cell (default behaviour)
     * hover - Generate tooltip when users mouse enters the cell
     */
    public String tooltipGenerationMode;
    /**
     * optional parameter to request a certain number of rows per page
     */
    public int paginationSize = 5;

    //All Pagination
    /**
     * set url for ajax request
     */
    public String ajaxURL;
    /**
     * set any standard parameters to pass with the request
     */
    public Any ajaxParams;

    //Remote Pagination
    /**
     * By default a url will be generated using the provided ajaxURL and a number of system generated parameters:
     * <p>
     * page - the page number being requested
     * size - the number of rows to a page (if paginationSize is set)
     * sorters - the first current sorters(if any)
     * filter - an array of the current filters (if any)
     * <p>
     * If you need to change the names of any of these parameters to fit your existing system, you can use the paginationDataSent option to set alternative parameter names.
     */
    public JsMap<String, String> paginationDataSent;
    /**
     * If you need to change the names of any of these parameters to fit your
     * existing system, you can use the paginationDataReceived option to set
     * alternative parameter names.
     */
    public JsMap<String, String> paginationDataReceived;
    /**
     * build pagination controls in this element.
     * <p>
     * By default the pagination controls are added to the footer of the table. If you wish the controls to be created in another element pass a DOM node or a CSS selector for that element to the paginationElement option.
     */
    public Node paginationElement;
    /**
     * The number of pagination page buttons shown in the footer using the paginationButtonCount option. By default this has a value of 5
     */
    public int paginationButtonCount = 5;
    /**
     * Enable page size select element and generate list options.
     * <p>
     * If you would like the user to be able to set the number of rows on each page, you can use the paginationSizeSelector option, which will add a page size selection select element to the table footer.
     */
    public BooleanOrIntArray paginationSizeSelector;

    //Pagination Control Element
    /**
     * When using the addRow function on a paginated table, rows will be added relative to the current page (ie to the top or bottom of the current page), with overflowing rows being shifted onto the next page.
     * <p>
     * If you would prefer rows to be added relative to the table (firs/last page) then you can use the paginationAddRow option. it can take one of two values:
     * <p>
     * page - add rows relative to current page (default)
     * table - add rows relative to the table
     */
    public String paginationAddRow;

    /**
     * Rows can be grouped by a common field value by setting the groupBy option to the name of the field to be grouped
     */
    public GroupByUnion groupBy;

    /**
     * You can set the contents of the group headers with the groupHeader option. This should return the contents of the group header.
     */
    public GroupHeaderUnion groupHeader;

    /**
     * You can set the default open state of groups using the groupStartOpen property.
     */
    public GroupStartOpenUnion groupStartOpen;

    /**
     * By default Tabulator allows users to toggle a group open or closed by clicking on the arrow icon in the left of the group header. If you would prefer a different behaviour you can use the groupToggleElement option to choose a different option:
     * <p>
     * The option can take one of three values:
     * <p>
     * "arrow" - togggle group on arrow element click
     * "header" - toggle group on click anywhere on the group header element
     * false - prevent clicking anywhere in the group toggling the group
     */
    public StringOrBoolean groupToggleElement;

    /**
     * By default Tabulator will create groups for rows based on the values contained in the row data. if you want to explicitly define which field values groups should be created for at each level, you can use the groupValues option.
     * <p>
     * This option takes an array of value arrays, each item in the first array should be a list of acceptable field values for groups at that level
     * <p>
     * Rows with values not in the arrays will not be show in the table. In this mode empty groups will remain visible in the table.
     * <p>
     * If you want to only specify groups for some of the levels, you can pass a value of false into the levels where you want Tabulator to decide on the grouping.
     */
    public JsObject[][] groupValues;
    /**
     * To keep the layout of the columns consistent, once the column widths have been set on the first data load (either from the data property in the constructor or the setData function) they will not be changed when new data is loaded.
     * If you would prefer that the column widths adjust to the data each time you load it into the table you can set the layoutColumnsOnNewData property to true.
     */
    boolean layoutColumnsOnNewData;
    /**
     * Responsive layout will automatically hide/show columns to fit the width of the Tabulator element. This allows for clean rendering of tables on smaller mobile devices, showing important data while avoiding horizontal scroll bars. You can enable responsive layouts using the responsiveLayout option.
     * There are two responsive layout modes available:
     * "hide" - hide columns that no longer fit in the table
     * "collapse" - collapse columns that no longer fit on the table into a list under the row
     * "collapse" - the values from hidden columns will be displayed in a title/value list under the row.
     * true - enable responsive layouts
     */
    StringOrBoolean responsiveLayout;
    /**
     * return request url.
     * <p>
     * url - the url from the ajaxURL property or setData function
     * config - the request config object from the ajaxConfig property
     * params - the params object from the ajaxParams property, this will also include any pagination, filter and sorting properties based on table setup
     */
    CallbackRet3<String, AjaxConfig, Any, String> ajaxURLGenerator;


    //Tree Structure and Nested Data

    /**
     * To enable data trees in your table, set the dataTree property to true in your table constructor:
     */
    public boolean dataTree;

    /**
     * By default Tabulator will look for child rows in the _children field of a row data object. You can change this to look in a different field using the dataTreeChildField property in your table constructor:
     */
    public String dataTreeChildField;


    /**
     * The toggle button that allows users to collapse and expand the column can be customised to meet your needs. There are two options, dataTreeExpandElement and dataTreeCollapseElement, that can be set to replace the default toggle elements with your own.
     * <p>
     * Both options can take either an html string representing the contents of the toggle element Or a DOM element representing the toggle.
     */

    public StringOrNode dataTreeCollapseElement;

    public StringOrNode dataTreeExpandElement;

    /**
     * By default the toggle element will be inserted into the first column on the table. If you want the toggle element to be inserted in a different column you can pass the feild name of the column to the dataTreeElementColumn setup option
     */
    public String dataTreeElementColumn;


    /**
     * The branch element can be turned off by setting the dataTreeBranchElement propety to false in the table constructor. Alternatively the branch element can be replaced with one of your choosing. As with the other tree elements this can be provided either as HTML or as a DOM element.
     */

    public StringOrNodeOrBoolean dataTreeBranchElement;

    /**
     * When a child row is displayed under its parent it is indented to make the distinction clearer. The size of the indent can be set by passing an integer representing the number of pixels for the indent to the dataTreeChildIndent property in the table constructor.
     */
    public int dataTreeChildIndent;

    /**
     * By default all nodes on the tree will start collapsed, you can customize the initial expansion state of the tree using the dataTreeStartExpanded option.
     * <p>
     * This option can take one of three possible value types, either a boolean to indicate whether all nodes should start expanded or collapsed:
     */
    public TreeStartExpandedUnion dataTreeStartExpanded;

    /**
     * You can use the row component passed into any of Tabulator's callbacks to trigger tree events on that row.
     */
    public Callback2<Event, RowComponent.Lookup> rowClick;

    //Localization

    /**
     * You can either pass in a string matching one of the language options you have defined, or pass in the boolean true which will cause Tabulator to auto-detect the browsers language settings from the navigator.language object
     */
    public StringOrBoolean locale;

    /**
     * You can store as many languages as you like, creating an object inside the langs object with a property of the locale code for that language. A list of locale codes can be found here.  if Tabulator cant find a match, it will try and find the next best thing
     */
    public Any langs;


    /**
     * By default any new rows will be added to the bottom of the table, to change this to the top set the addRowPos option to "top";
     */
    public String addRowPos;

    /**
     * When the table is first created it can be defined with an initial set of filters. These can be set using the initialFilter option. This will take the same filter array as the setFilter function.
     */
    public Filter[][] initialFilter;

    //Header filtering

    /**
     * When the table is first created it can be defined with an initial set of header filter values. These can be set using the initialHeaderFilter option. This will take an array of objects with the value for the filter and the column header it should be set on.
     */
    public HeaderFilter[] initialHeaderFilter;


    /**
     * If an input element is used as the filter element, the table will be filtered in real time as the user types in the input element. To prevent exessive redrawing of the table Tabulator will wait 300 miliseconds after the user has finished typing before tirggering the filter, this ensures that the table is not redrawn for every character typed by the user.
     * <p>
     * Note: If the input has a type attribute value of text it will be automatically changed to search to give the user the option to clear the input text.
     * <p>
     * If you would prefer that the input element behave like a standard editor without live updating the table, you can set the headerFilterLiveFilter column definition property to false
     */
    public boolean headerFilterLiveFilter;


    /**
     * By default Tabulator will clear the filter when it considers the header filter value to be empty, in the case of most filters that is if the value is undefined, null, or "", or in the case of check boxes that is if the value is not either true or false.
     * <p>
     * If you are using a custom filter or want to alter what an existing filter considers empty, you can pass a function to the headerFilterEmptyCheck column definition property. This function will be passed in the value of the filter as an argument and should return a boolean where true represents an empty filter
     */
    public CallbackRet1<Any, Boolean> headerFilterEmptyCheck;


    /**
     * By default Tabulator will try and match the comparison type to the type of element used for the header filter.
     * <p>
     * Standard input elements will use the "like" filter, this allows for the matches to be displayed as the user types.
     * <p>
     * For all other element types (select boxes, check boxes, input elements of type number) an "=" filter type is used.
     * <p>
     * If you want to specify the type of filter used you can pass it to the headerFilterFunc option in the column definition object. This will take any of the standard filters outlined above or a custom function:
     */
    public HeaderFilterFunc headerFIlterFunct;

    /**
     * It is possible to pass additional parameters to the custom filter function by passing an object to the headerFilterFuncParams option in the column definition.
     */
    public JsPropertyMap<String> headerFilterFuncParams;

    /**
     * The default placeholder text used for input elements can be set using the headerFilterPlaceholder option in the table definition
     */
    public String headerFilterPlaceholder;


    /**
     * If you would prefer to filter your data server side rather than in Tabulator, you can use the ajaxFiltering option to send the filter data to the server instead of processing it client side
     * An array of filters objects will then be passed in the filters parameter of the request, the name of this parameter can be set in the paginationDataSent option, in the pagination module.
     * <p>
     * The array of filter objects will take the same form as those returned from the getFilters function:
     * <p>
     * [
     * {field:"age", type:">", value:52}, //filter by age greater than 52
     * {field:"height", type:"<", value:142}, //and by height less than 142
     * ]
     * <p>
     * If a custom filter function is being used then the type parameter will have a value of "function".
     * If the table is not currently filtered then the array will be empty.
     */
    public boolean ajaxFiltering;

    //Calculation Functions

    public Calculator topCalc;
    public CalculatorParams topCalcParams;
    public Calculator bottomCalc;
    public CalculatorParams bottomCalcParams;

    /**
     * By default column calculations are shown at the top and bottom of the table, unless row grouping is enabled, in which case they are shown at the top and bottom of each group.
     * The columnCalcs option lets you decided where the calculations should be displayed, it can take one of four values:
     * true - show calcs at top and bottom of the table, unless grouped, then show in groups (boolean, default)
     * both - show calcs at top and bottom of the table and show in groups
     * table - show calcs at top and bottom of the table only
     * group - show calcs in groups only
     */
    public StringOrBoolean columnCalcs;


    /**
     * By default Tabulator will hide column calculations in groups when the group is toggled closed. If you would like column calculations to display when a group is closed, set the groupClosedShowCalcs option to true.
     */
    public boolean groupClosedShowCalcs;

    /**
     * You can apply formatters (see Formatting Data for more information) to any calculation cells, using the topCalcFormatter and bottomCalcFormatter options in a columns definition object. you can also pass in additional parameters to the formatter functions using the topCalcFormatterParams and bottomCalcFormatterParams options:
     */
    public FormatterUnion topCalcFormatter;
    public FormatterUnion bottomCalcFormatter;
    public FormatterParamsUnion topCalcFormatterParams;
    public FormatterParamsUnion bottomCalcFormatterParams;


    /**
     * The default ScrollTo position can be set using the scrollToColumnPosition option. It can take one of three possible values:
     * <p>
     * left - position column with its left edge at the left of the table (default)
     * center - position column with its left edge in the center of the table
     * right - position column with its right edge at the right of the table
     */
    public String scrollToColumnPosition;

    /**
     * The default option for triggering a ScrollTo on a visible element can be set using the scrollToColumnIfVisible option. It can take a boolean value:
     * <p>
     * true - scroll to column, even if it is visible (default)
     * false - scroll to column, unless it is currently visible, then don't move
     */
    public boolean scrollToColumnIfVisible;


    /**
     * The default ScrollTo position can be set using the scrollToRowPosition option. It can take one of four possible values:
     * <p>
     * top - position row with its top edge at the top of the table (default)
     * center - position row with its top edge in the center of the table
     * bottom - position row with its bottom edge at the bottom of the table
     * nearest - position row on the edge of the table it is closest to
     */
    public String scrollToRowPosition;

    /**
     * The default option for triggering a ScrollTo on a visible element can be set using the scrollToRowIfVisible option. It can take a boolean value:
     * true - scroll to row, even if it is visible (default)
     * false - scroll to row, unless it is currently visible, then don't move
     */
    public boolean scrollToRowIfVisible;

    //Key Bindings


    /**
     * If you would prefer to use different key combinations then that is no problem, you can use the keybindings option to change any of the above bindings.
     * <p>
     * The keybindings option takes an object that should consist of properties with the name of the action you wish to bind and a value of the key code string.
     * <p>
     * The key code should consist of the keycodes for the keys to be pressed, separated by the + symbol. The exceptions to this are ctrl and shift which should be used to check that the ctrl or shift keys are pressed as well.
     */
    public BooleanOrJsPropertyMap<String> keybindings;


    //Movable Rows and Columns

    /**
     * Enable user movable rows.
     */
    public boolean movableRows;

    /**
     * The rowMoved callback will be triggered when a row has been successfuly moved.
     */
    public Callback1<RowComponent> rowMoved;

    /**
     * Tabulator also allows you to move rows between tables. To enable this you should supply either a valid CSS selector string a DOM node for the table or the Tabuator object for the table to the movableRowsConnectedTables option. if you want to connect to multple tables then you can pass in an array of values to this option.
     */
    public StringOrNodeOrArray movableRowsConnectedTables;

    /**
     * The movableRowsReceiver option should be set on the receiving tables, and sets the action that should be taken when the row is dropped into the table.
     * <p>
     * There are several inbuilt receiver functions:
     * <p>
     * insert - inserts row next to the row it was dropped on, if not dropped on a row it is added to the table (default)
     * add - adds row to the table
     * update - updates the row it is dropped on with the sent rows data
     * replace - replaces the row it is dropped on with the sent row
     * <p>
     * You can also pass a callback to the movableRowsReceiver option for custom receiver functionality. the callback must return a boolean to indicate whether the drop should be considered successful or not (eg. you may want to reject a drop if it was not on a row)
     */

    public MovablerowsReceiver movableRowsReceiver;


    /**
     * The movableRowsSender option should be set on the sending table, and sets the action that should be taken after the row has been successfuly dropped into the receiving table.
     * There are several inbuilt sender functions:
     * <p>
     * false - do nothing(default).
     * "delete" - deletes the row from the table.
     * <p>
     * You can also pass a callback to the movableRowsSender option for custom sender functionality.
     */
    public MovableRowsSender movableRowsSender;


    /**
     * To allow the user to move columns along the table, set the movableColumns parameter in the options.
     */
    public boolean movableColumns;


    //Row Selection

    /**
     * To enable row selection, set the selectable option to true
     * <p>
     * The selectable option can take one of a several values:
     * <p>
     * false - selectable rows are disabled
     * true - selectable rows are enabled, and you can select as many as you want
     * integer - any integer value, this sets the maximum number of rows that can be selected (when the maximum number of selected rows is exeded, the first selected row will be deselected to allow the next row to be selected).
     * "highlight" (default) - rows have the same hover stylings as selectable rows but do not change state when clicked. This is great for when you want to show that a row is clickable but don't want it to be selectable.
     * <p>
     * Note: using the setData function will clear the currently selected rows.
     */
    public Selectable selectable;

    //Range Selection
    /**
     * By default you can select a range of rows by holding down the shift key and click dragging over a number of rows to toggle the selected state state of all rows the cursor passes over.
     * <p>
     * If you would prefere to select a range of row by clicking on the first row then holding down shift and clicking on the end row then you can acheive this by setting the selectableRangeMode to click
     * In this mode, in order to select multiple non-continuous rows, you need to hold down the ctrl key and click on each row in turn.
     */
    public String selectableRangeMode;

    //Rolling Selection
    /**
     * By default, row selection works on a rolling basis,
     * if you set the selectable option to a numeric value then
     * when you select past this number of rows, the first row
     * to be selected will be deselected. If you want to disable
     * this behaviour and instead prevent selection of new rows
     * once the limit is reached you can set the selectableRollingSelection option to false.
     */
    public boolean selectableRollingSelection;


    //Persistent Selection

    /**
     * By default Tabulator will maintain selected rows when the table is filtered, sorted or paginated (but NOT when the setData function is used). If you want the selected rows to be cleared whenever the table view is updated then set the selectablePersistence option to false.
     */
    public boolean selectablePersistence;


    //Selection Eligibility

    /**
     * You many want to exclude certain rows from being selected. The selectableCheck options allows you to pass a function to check if the current row should be selectable, returning true will allow row selection, false will result in nothing happening. The function should accept a RowComponent as its first argument.
     * Note: Any selectable rows will be assigned the tabulator-selectable class, any unselectable rows will be assigned the tabulator-unselectable class.
     */
    public Callback1<RowComponent> selectableCheck;

    //Interaction History
    /**
     * To enable the history functionality, set the history option to true, in the table constructor object.
     * <p>
     * The history module tracks the following actions:
     * <p>
     * Cell Edits
     * Row Added
     * Row Deleted
     * Row Moved
     */
    public boolean history;

    //Persistence Mode

    /**
     * Persistence information can either be stored in a cookie or in the localSotrage object, you can use the persistenceMode to choose which. It can take three possible values:
     * <p>
     * local - (string) Store the persistence information in the localStorage object
     * cookie - (string) Store the persistence information in a cookie
     * true - (boolean) check if localStorage is available and store persistence information, otherwise store in cookie (Default option)
     */
    public StringOrBoolean persistenceMode;


    /**
     * Persistence ID - id string, can only be numbers, letters, hyphens and underscores.
     * <p>
     * ou are planning on having multiple tables on the same page using persistence then Tabulator needs a way to uniquely identify each table. There are two ways to do this either set the id attribute on the element that will hold the table, Tabulator will automatically use this id as a reference for the persistence id.
     *
     * <div id="example-table"></div>
     * <p>
     * Alternatively if you do not want to give an id to the table holding element you can set the tabulator options parameter persistenceID to a unique persistence id for that table.
     */
    public String persistenceID;


    /**
     * Enable column layout persistence - You can ensure the layout of columns is stored for the next page load by setting the persistentLayout option to true
     * <p>
     * Note: If you update the column definition array after the the column layout has been stored, Tabulator will attempt to match the stored columns against the new definition. If you have any issues with column definitions updating then you will have to change the persistenceID or delete your cookies/local storage to clear out the old column layout information.
     */
    public boolean persistentLayout;


    //Persistent Sort
    /**
     * Enable sort persistence - You can ensure the data sorting is stored for the next page load by setting the persistentSort option to true.
     */
    public boolean persistentSort;


    //Persistent Filter
    /**
     * Enable filter persistence - You can ensure the data filtering is stored for the next page load by setting the persistentFilter option to true
     * <p>
     * Note: Only built-in filters can be stored (including module), custom filter functions cannot be persistently stored.
     * <p>
     * Note: Header filters are not currently stored persistently, this feature will be coming in a future release.
     */
    public boolean persistentFilter;


    //Clipboard
    /**
     * Enable clipboard functionality - You can enable clipboard functionality using the clipboard config option. It can take one of four possible values:
     * <p>
     * true - enable clipboard copy and paste
     * "copy" - enable only copy functionality
     * "paste" - enable only paste functionality
     * false - disable all clipboard functionality (default)
     */
    public StringOrBoolean clipboard;


    /**
     * Default copy selector
     */
    public ClipboardCopySelector clipboardCopySelector;

    /**
     * Default copy configuration.
     */
    public ClipboardCopyConfig clipboardCopyConfig;

    /**
     * By default Tabulator will include the column header titles in any clipboard data, this can be turned off by passing a value of false to the clipboardCopyHeader property:
     */
    public boolean clipboardCopyHeader;

    /**
     * Default clipboard copy formatter
     */
    public ClipboardCopyFormatter clipboardCopyFormatter;

    /**
     * Copy Style.
     * By default Tabulator will copy some of the tables styling along with the data to give a better visual appearance when pasted into other documents.
     * <p>
     * If you want to only copy the unstyled data then you should set the clipboardCopyStyled option to false in the table options object:
     */
    public boolean clipboardCopyStyled;


    /**
     * Custom paste parser
     */
    public ClipboardPasteParser clipboardPasteParser;

    public ClipboardPasteAction clipboardPasteAction;

    /**
     * By default Tabulator includes column headers, row groups and column calculations in the download output.
     * <p>
     * You can choose to remove column headers groups, row groups or column calculations from the output data by setting the values in the downloadConfig option in the table definition.
     *
     * Availabilitity.
     * Not all downloaders support column header groups, row groups and column calculations, see the documentation for each downloader for full information.
     */
    public DownloadConfig downloadConfig;

}
